library(MASS)
# MPN Fit ----
# Uses the Ebel model modified by Kowalcyk
# Important: Returns in LN format! Use log10(exp()) to correct
mpn_fit <- function(mpn_data, n_total, n_pos_test, n_pos_test_mpn, n_tubes, type) {
# MPN ----
N.total <- n_total
N.pos.test <- n_pos_test
N.pos.test.mpn <- n_pos_test_mpn
N.ND <- N.total - N.pos.test
num.tubes <- n_tubes
if (type == "ground") {
v.screen <- 325 # From Kowalcyk Model-turkey
v.mpn <- 1 # From Kowalcyk Model-turkey: Ground model does not use v.mpn, set to 1 so that we don't have to create multiple files
} else if (type == "parts") {
v.screen <- 136.35 # From Kowalcyk Model-chicken
v.mpn <- 45.45 # From Kowalcyk Model-chicken
}
screen.results <- c(
rep(1,N.pos.test.mpn),
rep(1,N.pos.test-N.pos.test.mpn),
rep(0,N.total-N.pos.test)
)
data <- list(
v.screen = v.screen,
v.mpn = v.mpn,
N.tubes = num.tubes,
N.total = N.total,
N.pos.test.mpn = N.pos.test.mpn,
tube = mpn_data,
screened = screen.results
)
inits = list(
list(lambda = rlnorm(N.total,-9,0.02), tau = 0.05, .RNG.seed=1,.RNG.name= 'base::Wichmann-Hill'), # random seed
list(lambda = rlnorm(N.total,-6,0.03), tau = 0.3, .RNG.seed=2,.RNG.name= 'base::Wichmann-Hill'),
list(lambda = rlnorm(N.total,-2.5,0.01), tau = 0.1, .RNG.seed=3,.RNG.name= 'base::Wichmann-Hill')
)
n.adapt = 5000  # n iteration for adaptation
n.update = 10000  # n iterations to add
n.iter = 5000 # n iteration to keep in the final chain
n.thinval = 10 # Thinning constant (10).  (Use n.thinval = 1 when just checking out the model run).
burn.in = 100
set.seed(1)
if (n_tubes==3) {
model <- jags.model(
"JAGS_MPN_Model.jag",
n.adapt = n.adapt,
n.chains = 3,
inits = inits,
data = data
)
} else if(n_tubes==5) {
model <- jags.model(
"JAGS_MPN_Model_5-Tube.jag",
n.adapt = n.adapt,
n.chains = 3,
inits = inits,
data = data
)
}
suppressWarnings(update(
model,
n.iter = n.update
))
zm1 <- coda.samples(
model,
variable.names = c("mu","tau"),
n.iter = n.iter,
thin = n.thinval
)
(SummaryResults=summary(window(zm1, start = burn.in), quantiles=c(0.025, 0.5, 0.975)))
mu=    c(window(zm1[[1]][,1],start=burn.in),
window(zm1[[2]][,1],start=burn.in),
window(zm1[[3]][,1],start=burn.in))
tau=    c(window(zm1[[1]][,2],start=burn.in),  # change subscript as needed
window(zm1[[2]][,2],start=burn.in),
window(zm1[[3]][,2],start=burn.in))
sigma= sqrt(1/tau)
# Plots and outputs:
summary_stats <- as.data.frame(cbind(pastecs::stat.desc(mu), pastecs::stat.desc(sigma)) )
names(summary_stats) <- c("mu","sigma")
fit <- c(mean(mu), mean(sigma))
return(summary_stats)
}
# rh_fit <- qpcr_fit(subset_data, 10^-1.48, 10^0, 10^4, 10^8, "qPCR")
qpcr_fit <- function (input_table, lod, enumeration_lower, enumeration_upper, upper_bound, method, full=TRUE) {
# Create left/right table ----
left_right_table <- data.frame(
matrix(
ncol = 2,
nrow = dim(input_table)[1]
)
)
colnames(left_right_table) <- c('left', 'right')
colnames(input_table) <- c("test","value")
# fill left/right table ----
i <- 1
while (i <= dim(input_table)[1]) {
if (grepl("qPCR", method)) {
x <- input_table$value[i]
} else if (grepl("plate count", method)|grepl("APC", method)) {
x <- input_table$value[i]
}
y <- input_table$test[i]
# TO DO: Zero detection
if (y=="Positive") {
if (grepl(">", x)) { # Has a "<", above enumeration_upper and cannot convert to a "real number" with as.numeric
left_right_table$left[i] <- (enumeration_upper)
left_right_table$right[i] <- (upper_bound)
} else if (grepl("<", x)) { # Has a "<", below enumeration_lower and cannot convert to a "real number" with as.numeric
left_right_table$left[i] <- (lod)
left_right_table$right[i] <- (enumeration_lower)
} else {
x <- as.numeric(x) # Is a "real number" and can be checked with numerical rules
}
if (enumeration_upper<x) { # Above enumeration_upper
left_right_table$left[i] <- (enumeration_upper)
left_right_table$right[i] <- (upper_bound)
} else if ((enumeration_lower)<=x & x<=(enumeration_upper)) { # Between enumeration_lower and enumeration_upper
left_right_table$left[i] <- x/(1814/400)
left_right_table$right[i] <- x/(1814/400)
} else if (x < enumeration_lower) { # Below enumeration_lower
left_right_table$left[i] <- (lod)
left_right_table$right[i] <- (enumeration_lower)
}
} else if (y=="Negative") {
left_right_table$left[i] <- NA
if (full==FALSE) {
left_right_table$right[i] <- NA
} else {
left_right_table$right[i] <- (lod)
}
}
i <- i+1
}
if (full==FALSE) {
left_right_table <- left_right_table[-which(is.na(left_right_table$left) & is.na(left_right_table$right)),]
}
# Log10 ----
i <- 1
while (i <= length(left_right_table$left)) {
## Left ----
if (left_right_table$left[i]!=0 & !is.na(left_right_table$left[i])) {
left_right_table$left[i] <- log10(left_right_table$left[i])
}
# Right ----
if (left_right_table$right[i]!=0 & !is.na(left_right_table$right[i])) {
left_right_table$right[i] <- log10(left_right_table$right[i])
}
i <- i+1
}
# Return ----
fit <- (fitdistrplus::fitdistcens(left_right_table, "norm"))
return(fit)
}
cfu_threshold_cut <- function(cfu, values, types, rounding) {
values <- as.data.frame(values)
colnames(values) <- c("V1")
types <- as.data.frame(types)
colnames(types) <- c("V1")
count <- sum(as.numeric(as.character(values$V1[which(types$V1=="value")]))>as.numeric(cfu), na.rm = TRUE)
percentage <- round(count/length(values$V1)*100, rounding)
paste0(">", MASS::fractions(cfu), " CFU: ", count, " (", percentage, "%)")
}
cfu_threshold_cut_return <- function(cfu, values, types, rounding) {
values <- as.data.frame(values)
colnames(values) <- c("V1")
types <- as.data.frame(types)
colnames(types) <- c("V1")
count <-  sum(as.numeric(as.character(values$V1[which(types$V1=="value")]))>as.numeric(cfu), na.rm = TRUE)
if (!is.na(rounding)) {
percentage <- round(count/length(values$V1)*100, rounding)
} else {
percentage <- count/length(values$V1)*100
}
return(c(count, percentage))
}
fitted_count_parts <- function(mean, sd) {
cat(paste0(">10 CFU (Fit): ", round((1-pnorm(log10(10), mean, sd, TRUE))*100,2), "%\n>1 CFU (Fit): ", round((1-pnorm(log10(1), mean, sd, TRUE))*100,2), "%\n>1/(30*(1814/400)) CFU (Positive) (Fit): ", round((1-pnorm(log10(1/(30*(1814/400))), mean, sd, TRUE))*100,2), "%\n<1/(30*(1814/400) CFU (Negative) (Fit): ", round((pnorm(log10(1/(30*(1814/400))), mean, sd, TRUE))*100,2), "%\n"))
}
fitted_count_ground <- function(mean, sd) {
cat(paste0(">10 CFU (Fit): ", round((1-pnorm(log10(10), mean, sd, TRUE))*100,2), "%\n>1 CFU (Fit): ", round((1-pnorm(log10(1), mean, sd, TRUE))*100,2), "%\n>1/325 CFU (Positive) (Fit): ", round((1-pnorm(log10(1/325), mean, sd, TRUE))*100,2), "%\n<1/325 CFU (Negative) (Fit): ", round((pnorm(log10(1/325), mean, sd, TRUE))*100,2), "%\n"))
}
fitted_count_parts_return <- function(mean, sd, l=c(10,1,1/30)) {
return(c((1-pnorm(log10(l[1]), mean, sd, TRUE))*100, (1-pnorm(log10(l[2]), mean, sd, TRUE))*100, (1-pnorm(log10(l[3]), mean, sd, TRUE))*100, (pnorm(log10(l[3]), mean, sd, TRUE))*100))
}
fitted_count_ground_return <- function(mean, sd) {
return(c((1-pnorm(log10(10), mean, sd, TRUE))*100, (1-pnorm(log10(1), mean, sd, TRUE))*100, (1-pnorm(log10(1/325), mean, sd, TRUE))*100, (pnorm(log10(1/325), mean, sd, TRUE))*100))
}
MPN_Refence <- read.csv("MPN_Lookup.csv")
MPN_Refence_LOD <- MPN_Refence[c(1,40),]
MPN_Refence <- MPN_Refence[-c(1,40),]
MPN_Refence$MPN_Index <- as.double(MPN_Refence$MPN_Index)
fsis_haccp_turkey_2024 <- read.csv(paste0(sub("/Fitting", "", getwd()),"/raw data/FSIS_RAW_Poultry_combined_2024-09-16 (New).csv"))
fsis_haccp_turkey_2024 <- read.csv(paste0(sub("/Fitting", "", getwd()),"/raw data/FSIS_RAW_Poultry_combined_2024-09-16 (New).csv"))
fsis_haccp_turkey_2024 <- read.csv(paste0(sub("/Fitting", "", getwd()),"/raw data/FSIS_RAW_Poultry_combined_2024-09-16 (New).csv"))
library(readxl)
library(rjags) # https://mcmc-jags.sourceforge.io/
library(fitdistrplus)
library(stringr)
library(pastecs)
library(knitr)
library(MASS)
# MPN Fit ----
# Uses the Ebel model modified by Kowalcyk
# Important: Returns in LN format! Use log10(exp()) to correct
mpn_fit <- function(mpn_data, n_total, n_pos_test, n_pos_test_mpn, n_tubes, type) {
# MPN ----
N.total <- n_total
N.pos.test <- n_pos_test
N.pos.test.mpn <- n_pos_test_mpn
N.ND <- N.total - N.pos.test
num.tubes <- n_tubes
if (type == "ground") {
v.screen <- 325 # From Kowalcyk Model-turkey
v.mpn <- 1 # From Kowalcyk Model-turkey: Ground model does not use v.mpn, set to 1 so that we don't have to create multiple files
} else if (type == "parts") {
v.screen <- 136.35 # From Kowalcyk Model-chicken
v.mpn <- 45.45 # From Kowalcyk Model-chicken
}
screen.results <- c(
rep(1,N.pos.test.mpn),
rep(1,N.pos.test-N.pos.test.mpn),
rep(0,N.total-N.pos.test)
)
data <- list(
v.screen = v.screen,
v.mpn = v.mpn,
N.tubes = num.tubes,
N.total = N.total,
N.pos.test.mpn = N.pos.test.mpn,
tube = mpn_data,
screened = screen.results
)
inits = list(
list(lambda = rlnorm(N.total,-9,0.02), tau = 0.05, .RNG.seed=1,.RNG.name= 'base::Wichmann-Hill'), # random seed
list(lambda = rlnorm(N.total,-6,0.03), tau = 0.3, .RNG.seed=2,.RNG.name= 'base::Wichmann-Hill'),
list(lambda = rlnorm(N.total,-2.5,0.01), tau = 0.1, .RNG.seed=3,.RNG.name= 'base::Wichmann-Hill')
)
n.adapt = 5000  # n iteration for adaptation
n.update = 10000  # n iterations to add
n.iter = 5000 # n iteration to keep in the final chain
n.thinval = 10 # Thinning constant (10).  (Use n.thinval = 1 when just checking out the model run).
burn.in = 100
set.seed(1)
if (n_tubes==3) {
model <- jags.model(
"JAGS_MPN_Model.jag",
n.adapt = n.adapt,
n.chains = 3,
inits = inits,
data = data
)
} else if(n_tubes==5) {
model <- jags.model(
"JAGS_MPN_Model_5-Tube.jag",
n.adapt = n.adapt,
n.chains = 3,
inits = inits,
data = data
)
}
suppressWarnings(update(
model,
n.iter = n.update
))
zm1 <- coda.samples(
model,
variable.names = c("mu","tau"),
n.iter = n.iter,
thin = n.thinval
)
(SummaryResults=summary(window(zm1, start = burn.in), quantiles=c(0.025, 0.5, 0.975)))
mu=    c(window(zm1[[1]][,1],start=burn.in),
window(zm1[[2]][,1],start=burn.in),
window(zm1[[3]][,1],start=burn.in))
tau=    c(window(zm1[[1]][,2],start=burn.in),  # change subscript as needed
window(zm1[[2]][,2],start=burn.in),
window(zm1[[3]][,2],start=burn.in))
sigma= sqrt(1/tau)
# Plots and outputs:
summary_stats <- as.data.frame(cbind(pastecs::stat.desc(mu), pastecs::stat.desc(sigma)) )
names(summary_stats) <- c("mu","sigma")
fit <- c(mean(mu), mean(sigma))
return(summary_stats)
}
library(readxl)
library(rjags) # https://mcmc-jags.sourceforge.io/
library(fitdistrplus)
library(stringr)
library(pastecs)
library(knitr)
library(MASS)
# MPN Fit ----
# Uses the Ebel model modified by Kowalcyk
# Important: Returns in LN format! Use log10(exp()) to correct
mpn_fit <- function(mpn_data, n_total, n_pos_test, n_pos_test_mpn, n_tubes, type) {
# MPN ----
N.total <- n_total
N.pos.test <- n_pos_test
N.pos.test.mpn <- n_pos_test_mpn
N.ND <- N.total - N.pos.test
num.tubes <- n_tubes
if (type == "ground") {
v.screen <- 325 # From Kowalcyk Model-turkey
v.mpn <- 1 # From Kowalcyk Model-turkey: Ground model does not use v.mpn, set to 1 so that we don't have to create multiple files
} else if (type == "parts") {
v.screen <- 136.35 # From Kowalcyk Model-chicken
v.mpn <- 45.45 # From Kowalcyk Model-chicken
}
screen.results <- c(
rep(1,N.pos.test.mpn),
rep(1,N.pos.test-N.pos.test.mpn),
rep(0,N.total-N.pos.test)
)
data <- list(
v.screen = v.screen,
v.mpn = v.mpn,
N.tubes = num.tubes,
N.total = N.total,
N.pos.test.mpn = N.pos.test.mpn,
tube = mpn_data,
screened = screen.results
)
inits = list(
list(lambda = rlnorm(N.total,-9,0.02), tau = 0.05, .RNG.seed=1,.RNG.name= 'base::Wichmann-Hill'), # random seed
list(lambda = rlnorm(N.total,-6,0.03), tau = 0.3, .RNG.seed=2,.RNG.name= 'base::Wichmann-Hill'),
list(lambda = rlnorm(N.total,-2.5,0.01), tau = 0.1, .RNG.seed=3,.RNG.name= 'base::Wichmann-Hill')
)
n.adapt = 5000  # n iteration for adaptation
n.update = 10000  # n iterations to add
n.iter = 5000 # n iteration to keep in the final chain
n.thinval = 10 # Thinning constant (10).  (Use n.thinval = 1 when just checking out the model run).
burn.in = 100
set.seed(1)
if (n_tubes==3) {
model <- jags.model(
"JAGS_MPN_Model.jag",
n.adapt = n.adapt,
n.chains = 3,
inits = inits,
data = data
)
} else if(n_tubes==5) {
model <- jags.model(
"JAGS_MPN_Model_5-Tube.jag",
n.adapt = n.adapt,
n.chains = 3,
inits = inits,
data = data
)
}
suppressWarnings(update(
model,
n.iter = n.update
))
zm1 <- coda.samples(
model,
variable.names = c("mu","tau"),
n.iter = n.iter,
thin = n.thinval
)
(SummaryResults=summary(window(zm1, start = burn.in), quantiles=c(0.025, 0.5, 0.975)))
mu=    c(window(zm1[[1]][,1],start=burn.in),
window(zm1[[2]][,1],start=burn.in),
window(zm1[[3]][,1],start=burn.in))
tau=    c(window(zm1[[1]][,2],start=burn.in),  # change subscript as needed
window(zm1[[2]][,2],start=burn.in),
window(zm1[[3]][,2],start=burn.in))
sigma= sqrt(1/tau)
# Plots and outputs:
summary_stats <- as.data.frame(cbind(pastecs::stat.desc(mu), pastecs::stat.desc(sigma)) )
names(summary_stats) <- c("mu","sigma")
fit <- c(mean(mu), mean(sigma))
return(summary_stats)
}
# rh_fit <- qpcr_fit(subset_data, 10^-1.48, 10^0, 10^4, 10^8, "qPCR")
qpcr_fit <- function (input_table, lod, enumeration_lower, enumeration_upper, upper_bound, method, full=TRUE) {
# Create left/right table ----
left_right_table <- data.frame(
matrix(
ncol = 2,
nrow = dim(input_table)[1]
)
)
colnames(left_right_table) <- c('left', 'right')
colnames(input_table) <- c("test","value")
# fill left/right table ----
i <- 1
while (i <= dim(input_table)[1]) {
if (grepl("qPCR", method)) {
x <- input_table$value[i]
} else if (grepl("plate count", method)|grepl("APC", method)) {
x <- input_table$value[i]
}
y <- input_table$test[i]
# TO DO: Zero detection
if (y=="Positive") {
if (grepl(">", x)) { # Has a "<", above enumeration_upper and cannot convert to a "real number" with as.numeric
left_right_table$left[i] <- (enumeration_upper)
left_right_table$right[i] <- (upper_bound)
} else if (grepl("<", x)) { # Has a "<", below enumeration_lower and cannot convert to a "real number" with as.numeric
left_right_table$left[i] <- (lod)
left_right_table$right[i] <- (enumeration_lower)
} else {
x <- as.numeric(x) # Is a "real number" and can be checked with numerical rules
}
if (enumeration_upper<x) { # Above enumeration_upper
left_right_table$left[i] <- (enumeration_upper)
left_right_table$right[i] <- (upper_bound)
} else if ((enumeration_lower)<=x & x<=(enumeration_upper)) { # Between enumeration_lower and enumeration_upper
left_right_table$left[i] <- x/(1814/400)
left_right_table$right[i] <- x/(1814/400)
} else if (x < enumeration_lower) { # Below enumeration_lower
left_right_table$left[i] <- (lod)
left_right_table$right[i] <- (enumeration_lower)
}
} else if (y=="Negative") {
left_right_table$left[i] <- NA
if (full==FALSE) {
left_right_table$right[i] <- NA
} else {
left_right_table$right[i] <- (lod)
}
}
i <- i+1
}
if (full==FALSE) {
left_right_table <- left_right_table[-which(is.na(left_right_table$left) & is.na(left_right_table$right)),]
}
# Log10 ----
i <- 1
while (i <= length(left_right_table$left)) {
## Left ----
if (left_right_table$left[i]!=0 & !is.na(left_right_table$left[i])) {
left_right_table$left[i] <- log10(left_right_table$left[i])
}
# Right ----
if (left_right_table$right[i]!=0 & !is.na(left_right_table$right[i])) {
left_right_table$right[i] <- log10(left_right_table$right[i])
}
i <- i+1
}
# Return ----
fit <- (fitdistrplus::fitdistcens(left_right_table, "norm"))
return(fit)
}
cfu_threshold_cut <- function(cfu, values, types, rounding) {
values <- as.data.frame(values)
colnames(values) <- c("V1")
types <- as.data.frame(types)
colnames(types) <- c("V1")
count <- sum(as.numeric(as.character(values$V1[which(types$V1=="value")]))>as.numeric(cfu), na.rm = TRUE)
percentage <- round(count/length(values$V1)*100, rounding)
paste0(">", MASS::fractions(cfu), " CFU: ", count, " (", percentage, "%)")
}
cfu_threshold_cut_return <- function(cfu, values, types, rounding) {
values <- as.data.frame(values)
colnames(values) <- c("V1")
types <- as.data.frame(types)
colnames(types) <- c("V1")
count <-  sum(as.numeric(as.character(values$V1[which(types$V1=="value")]))>as.numeric(cfu), na.rm = TRUE)
if (!is.na(rounding)) {
percentage <- round(count/length(values$V1)*100, rounding)
} else {
percentage <- count/length(values$V1)*100
}
return(c(count, percentage))
}
fitted_count_parts <- function(mean, sd) {
cat(paste0(">10 CFU (Fit): ", round((1-pnorm(log10(10), mean, sd, TRUE))*100,2), "%\n>1 CFU (Fit): ", round((1-pnorm(log10(1), mean, sd, TRUE))*100,2), "%\n>1/(30*(1814/400)) CFU (Positive) (Fit): ", round((1-pnorm(log10(1/(30*(1814/400))), mean, sd, TRUE))*100,2), "%\n<1/(30*(1814/400) CFU (Negative) (Fit): ", round((pnorm(log10(1/(30*(1814/400))), mean, sd, TRUE))*100,2), "%\n"))
}
fitted_count_ground <- function(mean, sd) {
cat(paste0(">10 CFU (Fit): ", round((1-pnorm(log10(10), mean, sd, TRUE))*100,2), "%\n>1 CFU (Fit): ", round((1-pnorm(log10(1), mean, sd, TRUE))*100,2), "%\n>1/325 CFU (Positive) (Fit): ", round((1-pnorm(log10(1/325), mean, sd, TRUE))*100,2), "%\n<1/325 CFU (Negative) (Fit): ", round((pnorm(log10(1/325), mean, sd, TRUE))*100,2), "%\n"))
}
fitted_count_parts_return <- function(mean, sd, l=c(10,1,1/30)) {
return(c((1-pnorm(log10(l[1]), mean, sd, TRUE))*100, (1-pnorm(log10(l[2]), mean, sd, TRUE))*100, (1-pnorm(log10(l[3]), mean, sd, TRUE))*100, (pnorm(log10(l[3]), mean, sd, TRUE))*100))
}
fitted_count_ground_return <- function(mean, sd) {
return(c((1-pnorm(log10(10), mean, sd, TRUE))*100, (1-pnorm(log10(1), mean, sd, TRUE))*100, (1-pnorm(log10(1/325), mean, sd, TRUE))*100, (pnorm(log10(1/325), mean, sd, TRUE))*100))
}
MPN_Refence <- read.csv("MPN_Lookup.csv")
MPN_Refence_LOD <- MPN_Refence[c(1,40),]
MPN_Refence <- MPN_Refence[-c(1,40),]
MPN_Refence$MPN_Index <- as.double(MPN_Refence$MPN_Index)
fsis_haccp_turkey_2024 <- read.csv(paste0(sub("/Fitting", "", getwd()),"/raw data/FSIS_RAW_Poultry_combined_2024-09-16 (New).csv"))
getwd()
getwd()
fsis_haccp_turkey_2024 <- read.csv("C:\Users\yiyili2\Box\Poultry\USPoultry work part 2\Paper documents\GitHub Code\Li-2025-TurkeySalmonellaQMRA\Li-2025-TurkeySalmonellaQMRA\Raw data\FSIS_RAW_Poultry_combined_2024-09-16 (New).csv")
fsis_haccp_turkey_2024 <- subset(fsis_haccp_turkey_2024, select = c("ProjectCode", "CollectionDate", "SalmonellaSpAnalysis", "SalmonellaSerotype", "SalmonellaQPCRg"))
fsis_haccp_turkey_2024 <- fsis_haccp_turkey_2024[which(fsis_haccp_turkey_2024$ProjectCode=="HC_TU_COM01"),]
fsis_haccp_turkey_2024$CollectionDate <- as.Date.character(fsis_haccp_turkey_2024$CollectionDate, tryFormats = "%m/%d/%Y")
fsis_haccp_turkey_2021_number <- fsis_haccp_turkey_2024[which(fsis_haccp_turkey_2024$CollectionDate>="2021-01-01"& fsis_haccp_turkey_2024$CollectionDate<="2021-12-31"),]
fsis_haccp_turkey_2024$CollectionDate <- as.Date.character(fsis_haccp_turkey_2024$CollectionDate, tryFormats = "%m/%d/%Y")
fsis_haccp_turkey_2024 <- fsis_haccp_turkey_2024[which(fsis_haccp_turkey_2024$CollectionDate>="2023-04-05"),]
fsis_haccp_turkey_2024$CollectionDate <- as.Date.character(fsis_haccp_turkey_2024$CollectionDate, tryFormats = "%m/%d/%Y")
fsis_haccp_turkey_2024 <- fsis_haccp_turkey_2024[which(fsis_haccp_turkey_2024$CollectionDate>="2023-04-05"),]
fsis_haccp_turkey_2024 <- fsis_haccp_turkey_2024[which(fsis_haccp_turkey_2024$ProjectCode=="HC_TU_COM01"),]
fsis_haccp_turkey_2024$CollectionDate <- as.Date.character(fsis_haccp_turkey_2024$CollectionDate, tryFormats = "%m/%d/%Y")
fsis_haccp_turkey_2024$CollectionDate <- as.Date(fsis_haccp_turkey_2024$CollectionDate, tryFormats = "%m/%d/%Y")
fsis_haccp_turkey_2024 <- fsis_haccp_turkey_2024[which(fsis_haccp_turkey_2024$CollectionDate>="2023-04-05"),]
View(fsis_haccp_turkey_2024)
fsis_haccp_turkey_2021 <- read.csv("C:\Users\yiyili2\Box\Poultry\USPoultry work part 2\Paper documents\GitHub Code\Li-2025-TurkeySalmonellaQMRA\Li-2025-TurkeySalmonellaQMRA\Raw data\FSIS_RAW_Poultry_combined_2024-09-16 (New).csv")
fsis_haccp_turkey_2021 <- read.csv(paste0(sub("/Fitting", "", getwd()),"/raw data/FSIS_RAW_Poultry_combined_2024-09-16 (New).csv"))
fsis_haccp_turkey_2021 <- read.csv("C:\Users\yiyili2\Box\Poultry\USPoultry work part 2\Paper documents\GitHub Code\Li-2025-TurkeySalmonellaQMRA\Li-2025-TurkeySalmonellaQMRA\Raw data\FSIS_RAW_Poultry_combined_2024-09-16 (New).csv")
fsis_haccp_turkey_2024 <- read.csv("C:\Users\yiyili2\Box\Poultry\USPoultry work part 2\Paper documents\GitHub Code\Li-2025-TurkeySalmonellaQMRA\Li-2025-TurkeySalmonellaQMRA\Raw data\FSIS_RAW_Poultry_combined_2024-09-16 (New).csv")
fsis_haccp_turkey_2024 <- read.csv("C:/Users/yiyili2/Box/Poultry/USPoultry work part 2/Paper documents/GitHub Code/Li-2025-TurkeySalmonellaQMRA/Li-2025-TurkeySalmonellaQMRA/Raw data/FSIS_RAW_Poultry_combined_2024-09-16 (New).csv")
fsis_haccp_turkey_2024 <- subset(fsis_haccp_turkey_2024, select = c("ProjectCode", "CollectionDate", "SalmonellaSpAnalysis", "SalmonellaSerotype", "SalmonellaQPCRg"))
fsis_haccp_turkey_2024 <- fsis_haccp_turkey_2024[which(fsis_haccp_turkey_2024$ProjectCode=="HC_TU_COM01"),]
fsis_haccp_turkey_2024$CollectionDate <- as.Date(fsis_haccp_turkey_2024$CollectionDate, tryFormats = "%m/%d/%Y")
fsis_haccp_turkey_2021_number <- fsis_haccp_turkey_2024[which(fsis_haccp_turkey_2024$CollectionDate>="2021-01-01"& fsis_haccp_turkey_2024$CollectionDate<="2021-12-31"),]
fsis_haccp_turkey_2024 <- fsis_haccp_turkey_2024[which(fsis_haccp_turkey_2024$CollectionDate>="2023-04-05"),]
